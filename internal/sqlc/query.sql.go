// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"time"
)

const createPayment = `-- name: CreatePayment :one
insert into
    payments (
        id,
        user_id,
        amount_in_cents,
        "description",
        created_at
    )
values
    (?, ?, ?, ?, ?) returning id
`

type CreatePaymentParams struct {
	ID            string
	UserID        string
	AmountInCents int64
	Description   string
	CreatedAt     time.Time
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.ID,
		arg.UserID,
		arg.AmountInCents,
		arg.Description,
		arg.CreatedAt,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createRefund = `-- name: CreateRefund :one
insert into
    refunds (
        id,
        payment_id,
        user_id,
        "description",
        requested_at,
        updated_at,
        "status"
    )
values
    (?, ?, ?, ?, ?, ?, ?) returning id
`

type CreateRefundParams struct {
	ID          string
	PaymentID   string
	UserID      string
	Description string
	RequestedAt time.Time
	UpdatedAt   time.Time
	Status      int64
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createRefund,
		arg.ID,
		arg.PaymentID,
		arg.UserID,
		arg.Description,
		arg.RequestedAt,
		arg.UpdatedAt,
		arg.Status,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
select
    id, user_id, amount_in_cents, description, created_at
from
    payments
where
    id = ?
    and user_id = ?
`

type GetPaymentByIDParams struct {
	ID     string
	UserID string
}

func (q *Queries) GetPaymentByID(ctx context.Context, arg GetPaymentByIDParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByID, arg.ID, arg.UserID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountInCents,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getRefundByID = `-- name: GetRefundByID :one
select
    id, payment_id, user_id, description, requested_at, updated_at, status
from
    refunds
where
    id = ?
    and payment_id = ?
    and user_id = ?
`

type GetRefundByIDParams struct {
	ID        string
	PaymentID string
	UserID    string
}

func (q *Queries) GetRefundByID(ctx context.Context, arg GetRefundByIDParams) (Refund, error) {
	row := q.db.QueryRowContext(ctx, getRefundByID, arg.ID, arg.PaymentID, arg.UserID)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.UserID,
		&i.Description,
		&i.RequestedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getRefundByPaymentID = `-- name: GetRefundByPaymentID :one
select
    id, payment_id, user_id, description, requested_at, updated_at, status
from
    refunds
where
    payment_id = ?
    and user_id = ?
`

type GetRefundByPaymentIDParams struct {
	PaymentID string
	UserID    string
}

func (q *Queries) GetRefundByPaymentID(ctx context.Context, arg GetRefundByPaymentIDParams) (Refund, error) {
	row := q.db.QueryRowContext(ctx, getRefundByPaymentID, arg.PaymentID, arg.UserID)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.UserID,
		&i.Description,
		&i.RequestedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
select
    id, user_id, amount_in_cents, description, created_at
from
    payments
where 
    user_id = ?
`

func (q *Queries) ListPayments(ctx context.Context, userID string) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPayments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountInCents,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefunds = `-- name: ListRefunds :many
select
    id, payment_id, user_id, description, requested_at, updated_at, status
from
    refunds
where
    user_id = ?
`

func (q *Queries) ListRefunds(ctx context.Context, userID string) ([]Refund, error) {
	rows, err := q.db.QueryContext(ctx, listRefunds, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Refund
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.UserID,
			&i.Description,
			&i.RequestedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefund = `-- name: UpdateRefund :one
update refunds
set
    "description" = ?,
    updated_at = ?,
    "status" = ?,
    user_id = ?
where
    id = ? returning id, payment_id, user_id, description, requested_at, updated_at, status
`

type UpdateRefundParams struct {
	Description string
	UpdatedAt   time.Time
	Status      int64
	UserID      string
	ID          string
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) (Refund, error) {
	row := q.db.QueryRowContext(ctx, updateRefund,
		arg.Description,
		arg.UpdatedAt,
		arg.Status,
		arg.UserID,
		arg.ID,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.UserID,
		&i.Description,
		&i.RequestedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}
